// @flow strict

import type { ComponentType, ElementConfig, Node } from 'react';
import type { Asset, Manifest } from './webpack';

export type { Asset, Manifest };

declare export var MODE: {
  RENDER: string,
  HYDRATE: string,
};

declare export var SETTINGS: {
  CURRENT_MODE: typeof MODE.RENDER | typeof MODE.HYDRATE,
};

declare export var LooselyLazy: {
  init(mode: typeof SETTINGS.CURRENT_MODE): void,
};

declare export default typeof LooselyLazy;

export type LazyComponent<C> = ComponentType<ElementConfig<C>> & {
  getAssetUrls(manifest: Manifest): string[] | void,
  preload(): void,
};

type Options = {
  ssr?: boolean,
  defer?: number,
  moduleId?: string,
};

export type LazySuspenseProps = {
  children?: ?Node,
  fallback: Node,
};

declare export var LazySuspense: ComponentType<LazySuspenseProps>;

export type JavaScriptModule<C> = {
  default: C,
  ...
};

export type ClientLoader<C> = () => Promise<JavaScriptModule<C> | C>;

export type ServerLoader<C> = () => JavaScriptModule<C> | C;

// TODO: Reinstate ServerLoader<C> whenever flow better supports dynamic imports
export type Loader<C> = ClientLoader<C>; // | ServerLoader<C>;

export type { Options as LazyOptions };

declare export function lazyForPaint<C>(
  loader: Loader<C>,
  opts?: Options
): LazyComponent<C>;

declare export function lazyAfterPaint<C>(
  loader: Loader<C>,
  opts?: Options
): LazyComponent<C>;

declare export function lazy<C>(
  loader: Loader<C>,
  opts?: Options
): LazyComponent<C>;

export type LazyWaitProps = {
  until: boolean,
  children: Node,
};

declare export var LazyWait: ComponentType<LazyWaitProps>;

declare export function useLazyPhase(): {
  startNextPhase(): void,
  resetPhase(): void,
};
